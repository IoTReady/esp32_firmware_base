<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ESP32 Quick Start Building Blocks: botocore.configloader Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="customdoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="2" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ESP32 Quick Start Building Blocks
   </div>
   <!-- PROJECT BRIEF is expected to be a URL -->
   <div id="projectbrief"><a href=https://github.com/IoTReady/esp32_firmware_base>https://github.com/IoTReady/esp32_firmware_base</a></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('namespacebotocore_1_1configloader.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">botocore.configloader Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a2fd2c872855122130546202b934f069d"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebotocore_1_1configloader.html#a2fd2c872855122130546202b934f069d">multi_file_load_config</a> (*filenames)</td></tr>
<tr class="separator:a2fd2c872855122130546202b934f069d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51a931d39212bc5e755615daf3b69ff9"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebotocore_1_1configloader.html#a51a931d39212bc5e755615daf3b69ff9">load_config</a> (config_filename)</td></tr>
<tr class="separator:a51a931d39212bc5e755615daf3b69ff9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7589742f9a3c1fb00df0810c0e499737"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebotocore_1_1configloader.html#a7589742f9a3c1fb00df0810c0e499737">raw_config_parse</a> (config_filename, parse_subsections=True)</td></tr>
<tr class="separator:a7589742f9a3c1fb00df0810c0e499737"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f5c88bd0c239dd55847c074bdc89416"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebotocore_1_1configloader.html#a0f5c88bd0c239dd55847c074bdc89416">build_profile_map</a> (parsed_ini_config)</td></tr>
<tr class="separator:a0f5c88bd0c239dd55847c074bdc89416"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a0f5c88bd0c239dd55847c074bdc89416"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f5c88bd0c239dd55847c074bdc89416">&#9670;&nbsp;</a></span>build_profile_map()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def botocore.configloader.build_profile_map </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>parsed_ini_config</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Convert the parsed INI config into a profile map.

The config file format requires that every profile except the
default to be prepended with "profile", e.g.::

    [profile test]
    aws_... = foo
    aws_... = bar

    [profile bar]
    aws_... = foo
    aws_... = bar

    # This is *not* a profile
    [preview]
    otherstuff = 1

    # Neither is this
    [foobar]
    morestuff = 2

The build_profile_map will take a parsed INI config file where each top
level key represents a section name, and convert into a format where all
the profiles are under a single top level "profiles" key, and each key in
the sub dictionary is a profile name.  For example, the above config file
would be converted from::

    {"profile test": {"aws_...": "foo", "aws...": "bar"},
     "profile bar": {"aws...": "foo", "aws...": "bar"},
     "preview": {"otherstuff": ...},
     "foobar": {"morestuff": ...},
     }

into::

    {"profiles": {"test": {"aws_...": "foo", "aws...": "bar"},
                  "bar": {"aws...": "foo", "aws...": "bar"},
     "preview": {"otherstuff": ...},
     "foobar": {"morestuff": ...},
    }

If there are no profiles in the provided parsed INI contents, then
an empty dict will be the value associated with the ``profiles`` key.

.. note::

    This will not mutate the passed in parsed_ini_config.  Instead it will
    make a deepcopy and return that value.</pre> 
</div>
</div>
<a id="a51a931d39212bc5e755615daf3b69ff9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51a931d39212bc5e755615daf3b69ff9">&#9670;&nbsp;</a></span>load_config()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def botocore.configloader.load_config </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>config_filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Parse a INI config with profiles.

This will parse an INI config file and map top level profiles
into a top level "profile" key.

If you want to parse an INI file and map all section names to
top level keys, use ``raw_config_parse`` instead.</pre> 
</div>
</div>
<a id="a2fd2c872855122130546202b934f069d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fd2c872855122130546202b934f069d">&#9670;&nbsp;</a></span>multi_file_load_config()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def botocore.configloader.multi_file_load_config </td>
          <td>(</td>
          <td class="paramtype">*&#160;</td>
          <td class="paramname"><em>filenames</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Load and combine multiple INI configs with profiles.

This function will take a list of filesnames and return
a single dictionary that represents the merging of the loaded
config files.

If any of the provided filenames does not exist, then that file
is ignored.  It is therefore ok to provide a list of filenames,
some of which may not exist.

Configuration files are **not** deep merged, only the top level
keys are merged.  The filenames should be passed in order of
precedence.  The first config file has precedence over the
second config file, which has precedence over the third config file,
etc.  The only exception to this is that the "profiles" key is
merged to combine profiles from multiple config files into a
single profiles mapping.  However, if a profile is defined in
multiple config files, then the config file with the highest
precedence is used.  Profile values themselves are not merged.
For example::

    FileA              FileB                FileC
    [foo]             [foo]                 [bar]
    a=1               a=2                   a=3
                      b=2

    [bar]             [baz]                [profile a]
    a=2               a=3                  region=e

    [profile a]       [profile b]          [profile c]
    region=c          region=d             region=f

The final result of ``multi_file_load_config(FileA, FileB, FileC)``
would be::

    {"foo": {"a": 1}, "bar": {"a": 2}, "baz": {"a": 3},
    "profiles": {"a": {"region": "c"}}, {"b": {"region": d"}},
                {"c": {"region": "f"}}}

Note that the "foo" key comes from A, even though it's defined in both
FileA and FileB.  Because "foo" was defined in FileA first, then the values
for "foo" from FileA are used and the values for "foo" from FileB are
ignored.  Also note where the profiles originate from.  Profile "a"
comes FileA, profile "b" comes from FileB, and profile "c" comes
from FileC.</pre> 
</div>
</div>
<a id="a7589742f9a3c1fb00df0810c0e499737"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7589742f9a3c1fb00df0810c0e499737">&#9670;&nbsp;</a></span>raw_config_parse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def botocore.configloader.raw_config_parse </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>config_filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>parse_subsections</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Returns the parsed INI config contents.

Each section name is a top level key.

:param config_filename: The name of the INI file to parse

:param parse_subsections: If True, parse indented blocks as
   subsections that represent their own configuration dictionary.
   For example, if the config file had the contents::

       s3 =
          signature_version = s3v4
          addressing_style = path

    The resulting ``raw_config_parse`` would be::

        {'s3': {'signature_version': 's3v4', 'addressing_style': 'path'}}

   If False, do not try to parse subsections and return the indented
   block as its literal value::

        {'s3': '\nsignature_version = s3v4\naddressing_style = path'}

:returns: A dict with keys for each profile found in the config
    file and the value of each key being a dict containing name
    value pairs found in that profile.

:raises: ConfigNotFound, ConfigParseError
</pre> 
</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacebotocore.html">botocore</a></li><li class="navelem"><a class="el" href="namespacebotocore_1_1configloader.html">configloader</a></li>
    <li class="footer">Generated by <a href="https://iotready.co"> IoTReady </a><img class="footer" src="logo.png" width="30" height="30" alt="IoTReady"/></a></li>
  </ul>
</div>
</body>
</html>
