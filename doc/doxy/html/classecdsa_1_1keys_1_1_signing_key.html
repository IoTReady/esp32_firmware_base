<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ESP32 Quick Start Building Blocks: ecdsa.keys.SigningKey Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="customdoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="2" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ESP32 Quick Start Building Blocks
   </div>
   <!-- PROJECT BRIEF is expected to be a URL -->
   <div id="projectbrief"><a href=https://github.com/IoTReady/esp32_firmware_base>https://github.com/IoTReady/esp32_firmware_base</a></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classecdsa_1_1keys_1_1_signing_key.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="classecdsa_1_1keys_1_1_signing_key-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ecdsa.keys.SigningKey Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for ecdsa.keys.SigningKey:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classecdsa_1_1keys_1_1_signing_key.png" alt=""/>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a4a6620f27f105ecbe94af0086350e7e1"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecdsa_1_1keys_1_1_signing_key.html#a4a6620f27f105ecbe94af0086350e7e1">__init__</a> (self, _error__please_use_generate=None)</td></tr>
<tr class="separator:a4a6620f27f105ecbe94af0086350e7e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abab49e7f725d7a915727e29f01c7560e"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecdsa_1_1keys_1_1_signing_key.html#abab49e7f725d7a915727e29f01c7560e">__eq__</a> (self, other)</td></tr>
<tr class="separator:abab49e7f725d7a915727e29f01c7560e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22d83d79ce8b705604512b999fe65dbf"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecdsa_1_1keys_1_1_signing_key.html#a22d83d79ce8b705604512b999fe65dbf">__ne__</a> (self, other)</td></tr>
<tr class="separator:a22d83d79ce8b705604512b999fe65dbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89819de42dddf01304891866b0ae02f1"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecdsa_1_1keys_1_1_signing_key.html#a89819de42dddf01304891866b0ae02f1">generate</a> (cls, <a class="el" href="classecdsa_1_1keys_1_1_signing_key.html#a27531450389917558b2f1673f6476f82">curve</a>=NIST192p, entropy=None, hashfunc=sha1)</td></tr>
<tr class="separator:a89819de42dddf01304891866b0ae02f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad841769a6e0dabb690486b60a8095031"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecdsa_1_1keys_1_1_signing_key.html#ad841769a6e0dabb690486b60a8095031">from_secret_exponent</a> (cls, secexp, <a class="el" href="classecdsa_1_1keys_1_1_signing_key.html#a27531450389917558b2f1673f6476f82">curve</a>=NIST192p, hashfunc=sha1)</td></tr>
<tr class="separator:ad841769a6e0dabb690486b60a8095031"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a0986bf82fa43b7dcf005c559a760ed"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecdsa_1_1keys_1_1_signing_key.html#a7a0986bf82fa43b7dcf005c559a760ed">from_string</a> (cls, string, <a class="el" href="classecdsa_1_1keys_1_1_signing_key.html#a27531450389917558b2f1673f6476f82">curve</a>=NIST192p, hashfunc=sha1)</td></tr>
<tr class="separator:a7a0986bf82fa43b7dcf005c559a760ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12b2314fee1e419cf69de1d13d975671"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecdsa_1_1keys_1_1_signing_key.html#a12b2314fee1e419cf69de1d13d975671">from_pem</a> (cls, string, hashfunc=sha1, valid_curve_encodings=None)</td></tr>
<tr class="separator:a12b2314fee1e419cf69de1d13d975671"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb5dfb2ff1ea731781e6c25dfbe5276e"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecdsa_1_1keys_1_1_signing_key.html#abb5dfb2ff1ea731781e6c25dfbe5276e">from_der</a> (cls, string, hashfunc=sha1, valid_curve_encodings=None)</td></tr>
<tr class="separator:abb5dfb2ff1ea731781e6c25dfbe5276e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09689cd98260a48e527e6d469f52d362"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecdsa_1_1keys_1_1_signing_key.html#a09689cd98260a48e527e6d469f52d362">to_string</a> (self)</td></tr>
<tr class="separator:a09689cd98260a48e527e6d469f52d362"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3456753e9e100f802995ebb575d35ee"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecdsa_1_1keys_1_1_signing_key.html#ab3456753e9e100f802995ebb575d35ee">to_pem</a> (self, point_encoding=&quot;uncompressed&quot;, format=&quot;ssleay&quot;, curve_parameters_encoding=None)</td></tr>
<tr class="separator:ab3456753e9e100f802995ebb575d35ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af41d921262712c4f57fb546ff463f405"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecdsa_1_1keys_1_1_signing_key.html#af41d921262712c4f57fb546ff463f405">to_der</a> (self, point_encoding=&quot;uncompressed&quot;, format=&quot;ssleay&quot;, curve_parameters_encoding=None)</td></tr>
<tr class="separator:af41d921262712c4f57fb546ff463f405"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70a84090b2ce2317e06415d51c66e96c"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecdsa_1_1keys_1_1_signing_key.html#a70a84090b2ce2317e06415d51c66e96c">get_verifying_key</a> (self)</td></tr>
<tr class="separator:a70a84090b2ce2317e06415d51c66e96c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8a96e24413fb8a3da8d393ac7fd036e"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecdsa_1_1keys_1_1_signing_key.html#af8a96e24413fb8a3da8d393ac7fd036e">sign_deterministic</a> (self, data, hashfunc=None, sigencode=sigencode_string, extra_entropy=b&quot;&quot;)</td></tr>
<tr class="separator:af8a96e24413fb8a3da8d393ac7fd036e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10bee428751a86d1a20b352fada3f168"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecdsa_1_1keys_1_1_signing_key.html#a10bee428751a86d1a20b352fada3f168">sign_digest_deterministic</a> (self, digest, hashfunc=None, sigencode=sigencode_string, extra_entropy=b&quot;&quot;, allow_truncate=False)</td></tr>
<tr class="separator:a10bee428751a86d1a20b352fada3f168"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afeceda380c1286035caa98887463f497"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecdsa_1_1keys_1_1_signing_key.html#afeceda380c1286035caa98887463f497">sign</a> (self, data, entropy=None, hashfunc=None, sigencode=sigencode_string, k=None, allow_truncate=True)</td></tr>
<tr class="separator:afeceda380c1286035caa98887463f497"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a147bcf40b4a968c69106975666651901"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecdsa_1_1keys_1_1_signing_key.html#a147bcf40b4a968c69106975666651901">sign_digest</a> (self, digest, entropy=None, sigencode=sigencode_string, k=None, allow_truncate=False)</td></tr>
<tr class="separator:a147bcf40b4a968c69106975666651901"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5acd7a8d16c2e9ec7e3b2f6205e955cc"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecdsa_1_1keys_1_1_signing_key.html#a5acd7a8d16c2e9ec7e3b2f6205e955cc">sign_number</a> (self, number, entropy=None, k=None)</td></tr>
<tr class="separator:a5acd7a8d16c2e9ec7e3b2f6205e955cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a27531450389917558b2f1673f6476f82"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecdsa_1_1keys_1_1_signing_key.html#a27531450389917558b2f1673f6476f82">curve</a></td></tr>
<tr class="separator:a27531450389917558b2f1673f6476f82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca7644794fa76f443dca365d6a8e0dab"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecdsa_1_1keys_1_1_signing_key.html#aca7644794fa76f443dca365d6a8e0dab">default_hashfunc</a></td></tr>
<tr class="separator:aca7644794fa76f443dca365d6a8e0dab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a548e8ca04bd9aeeac8e1702b543a3e0d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecdsa_1_1keys_1_1_signing_key.html#a548e8ca04bd9aeeac8e1702b543a3e0d">baselen</a></td></tr>
<tr class="separator:a548e8ca04bd9aeeac8e1702b543a3e0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca047e8955fa7ed4514409611148a10b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecdsa_1_1keys_1_1_signing_key.html#aca047e8955fa7ed4514409611148a10b">verifying_key</a></td></tr>
<tr class="separator:aca047e8955fa7ed4514409611148a10b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e35bc07c03bd498969a7dcc4de390b1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecdsa_1_1keys_1_1_signing_key.html#a8e35bc07c03bd498969a7dcc4de390b1">privkey</a></td></tr>
<tr class="separator:a8e35bc07c03bd498969a7dcc4de390b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">Class for handling keys that can create signatures (private keys).

:ivar ecdsa.curves.Curve curve: The Curve over which all the cryptographic
    operations will take place
:ivar default_hashfunc: the function that will be used for hashing the
    data. Should implement the same API as hashlib.sha1
:ivar int baselen: the length of a :term:`raw encoding` of private key
:ivar ecdsa.keys.VerifyingKey verifying_key: the public key
    associated with this private key
:ivar ecdsa.ecdsa.Private_key privkey: the actual private key
</pre> </div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a4a6620f27f105ecbe94af0086350e7e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a6620f27f105ecbe94af0086350e7e1">&#9670;&nbsp;</a></span>__init__()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ecdsa.keys.SigningKey.__init__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>_error__please_use_generate</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Unsupported, please use one of the classmethods to initialise.</pre> 
</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="abab49e7f725d7a915727e29f01c7560e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abab49e7f725d7a915727e29f01c7560e">&#9670;&nbsp;</a></span>__eq__()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ecdsa.keys.SigningKey.__eq__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return True if the points are identical, False otherwise.</pre> 
</div>
</div>
<a id="a22d83d79ce8b705604512b999fe65dbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22d83d79ce8b705604512b999fe65dbf">&#9670;&nbsp;</a></span>__ne__()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ecdsa.keys.SigningKey.__ne__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return False if the points are identical, True otherwise.</pre> 
</div>
</div>
<a id="abb5dfb2ff1ea731781e6c25dfbe5276e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb5dfb2ff1ea731781e6c25dfbe5276e">&#9670;&nbsp;</a></span>from_der()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ecdsa.keys.SigningKey.from_der </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>hashfunc</em> = <code>sha1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>valid_curve_encodings</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Initialise from key stored in :term:`DER` format.

The DER formats supported are the un-encrypted RFC5915
(the ssleay format) supported by OpenSSL, and the more common
un-encrypted RFC5958 (the PKCS #8 format).

Both formats contain an ASN.1 object following the syntax specified
in RFC5915::

    ECPrivateKey ::= SEQUENCE {
      version        INTEGER { ecPrivkeyVer1(1) }} (ecPrivkeyVer1),
      privateKey     OCTET STRING,
      parameters [0] ECParameters {{ NamedCurve }} OPTIONAL,
      publicKey  [1] BIT STRING OPTIONAL
    }

`publicKey` field is ignored completely (errors, if any, in it will
be undetected).

Two formats are supported for the `parameters` field: the named
curve and the explicit encoding of curve parameters.
In the legacy ssleay format, this implementation requires the optional
`parameters` field to get the curve name. In PKCS #8 format, the curve
is part of the PrivateKeyAlgorithmIdentifier.

The PKCS #8 format includes an ECPrivateKey object as the `privateKey`
field within a larger structure:

    OneAsymmetricKey ::= SEQUENCE {
        version                   Version,
        privateKeyAlgorithm       PrivateKeyAlgorithmIdentifier,
        privateKey                PrivateKey,
        attributes            [0] Attributes OPTIONAL,
        ...,
        [[2: publicKey        [1] PublicKey OPTIONAL ]],
        ...
    }

The `attributes` and `publicKey` fields are completely ignored; errors
in them will not be detected.

:param string: binary string with DER-encoded private ECDSA key
:type string: bytes like object
:param valid_curve_encodings: list of allowed encoding formats
    for curve parameters. By default (``None``) all are supported:
    ``named_curve`` and ``explicit``.
:type valid_curve_encodings: :term:`set-like object`

:raises MalformedPointError: if the length of encoding doesn't match
    the provided curve or the encoded values is too large
:raises RuntimeError: if the generation of public key from private
    key failed
:raises UnexpectedDER: if the encoding of the DER file is incorrect

:return: Initialised SigningKey object
:rtype: SigningKey
</pre> 
</div>
</div>
<a id="a12b2314fee1e419cf69de1d13d975671"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12b2314fee1e419cf69de1d13d975671">&#9670;&nbsp;</a></span>from_pem()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ecdsa.keys.SigningKey.from_pem </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>hashfunc</em> = <code>sha1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>valid_curve_encodings</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Initialise from key stored in :term:`PEM` format.

The PEM formats supported are the un-encrypted RFC5915
(the ssleay format) supported by OpenSSL, and the more common
un-encrypted RFC5958 (the PKCS #8 format).

The legacy format files have the header with the string
``BEGIN EC PRIVATE KEY``.
PKCS#8 files have the header ``BEGIN PRIVATE KEY``.
Encrypted files (ones that include the string
``Proc-Type: 4,ENCRYPTED``
right after the PEM header) are not supported.

See :func:`~SigningKey.from_der` for ASN.1 syntax of the objects in
this files.

:param string: text with PEM-encoded private ECDSA key
:type string: str
:param valid_curve_encodings: list of allowed encoding formats
    for curve parameters. By default (``None``) all are supported:
    ``named_curve`` and ``explicit``.
:type valid_curve_encodings: :term:`set-like object`


:raises MalformedPointError: if the length of encoding doesn't match
    the provided curve or the encoded values is too large
:raises RuntimeError: if the generation of public key from private
    key failed
:raises UnexpectedDER: if the encoding of the PEM file is incorrect

:return: Initialised SigningKey object
:rtype: SigningKey
</pre> 
</div>
</div>
<a id="ad841769a6e0dabb690486b60a8095031"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad841769a6e0dabb690486b60a8095031">&#9670;&nbsp;</a></span>from_secret_exponent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ecdsa.keys.SigningKey.from_secret_exponent </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>secexp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>curve</em> = <code>NIST192p</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>hashfunc</em> = <code>sha1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Create a private key from a random integer.

Note: it's a low level method, it's recommended to use the
:func:`~SigningKey.generate` method to create private keys.

:param int secexp: secret multiplier (the actual private key in ECDSA).
    Needs to be an integer between 1 and the curve order.
:param curve: The curve on which the point needs to reside
:type curve: ecdsa.curves.Curve
:param hashfunc: The default hash function that will be used for
    signing, needs to implement the same interface
    as hashlib.sha1
:type hashfunc: callable

:raises MalformedPointError: when the provided secexp is too large
    or too small for the curve selected
:raises RuntimeError: if the generation of public key from private
    key failed

:return: Initialised SigningKey object
:rtype: SigningKey
</pre> 
</div>
</div>
<a id="a7a0986bf82fa43b7dcf005c559a760ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a0986bf82fa43b7dcf005c559a760ed">&#9670;&nbsp;</a></span>from_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ecdsa.keys.SigningKey.from_string </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>curve</em> = <code>NIST192p</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>hashfunc</em> = <code>sha1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Decode the private key from :term:`raw encoding`.

Note: the name of this method is a misnomer coming from days of
Python 2, when binary strings and character strings shared a type.
In Python 3, the expected type is `bytes`.

:param string: the raw encoding of the private key
:type string: bytes like object
:param curve: The curve on which the point needs to reside
:type curve: ecdsa.curves.Curve
:param hashfunc: The default hash function that will be used for
    signing, needs to implement the same interface
    as hashlib.sha1
:type hashfunc: callable

:raises MalformedPointError: if the length of encoding doesn't match
    the provided curve or the encoded values is too large
:raises RuntimeError: if the generation of public key from private
    key failed

:return: Initialised SigningKey object
:rtype: SigningKey
</pre> 
</div>
</div>
<a id="a89819de42dddf01304891866b0ae02f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89819de42dddf01304891866b0ae02f1">&#9670;&nbsp;</a></span>generate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ecdsa.keys.SigningKey.generate </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>curve</em> = <code>NIST192p</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>entropy</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>hashfunc</em> = <code>sha1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Generate a random private key.

:param curve: The curve on which the point needs to reside, defaults
    to NIST192p
:type curve: ecdsa.curves.Curve
:param entropy: Source of randomness for generating the private keys,
    should provide cryptographically secure random numbers if the keys
    need to be secure. Uses os.urandom() by default.
:type entropy: callable
:param hashfunc: The default hash function that will be used for
    signing, needs to implement the same interface
    as hashlib.sha1
:type hashfunc: callable

:return: Initialised SigningKey object
:rtype: SigningKey
</pre> 
</div>
</div>
<a id="a70a84090b2ce2317e06415d51c66e96c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70a84090b2ce2317e06415d51c66e96c">&#9670;&nbsp;</a></span>get_verifying_key()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ecdsa.keys.SigningKey.get_verifying_key </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return the VerifyingKey associated with this private key.

Equivalent to reading the `verifying_key` field of an instance.

:return: a public key that can be used to verify the signatures made
    with this SigningKey
:rtype: VerifyingKey
</pre> 
</div>
</div>
<a id="afeceda380c1286035caa98887463f497"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afeceda380c1286035caa98887463f497">&#9670;&nbsp;</a></span>sign()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ecdsa.keys.SigningKey.sign </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>entropy</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>hashfunc</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>sigencode</em> = <code>sigencode_string</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>k</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>allow_truncate</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Create signature over data using the probabilistic ECDSA algorithm.

This method uses the standard ECDSA algorithm that requires a
cryptographically secure random number generator.

It's recommended to use the :func:`~SigningKey.sign_deterministic`
method instead of this one.

:param data: data that will be hashed for signing
:type data: bytes like object
:param callable entropy: randomness source, os.urandom by default
:param hashfunc: hash function to use for hashing the provided `data`.
    If unspecified the default hash function selected during
    object initialisation will be used (see
    `VerifyingKey.default_hashfunc`).
    Should behave like hashlib.sha1. The output length of the
    hash (in bytes) must not be longer than the length of the curve
    order (rounded up to the nearest byte), so using SHA256 with
    NIST256p is ok, but SHA256 with NIST192p is not. (In the 2**-96ish
    unlikely event of a hash output larger than the curve order, the
    hash will effectively be wrapped mod n).
    Use hashfunc=hashlib.sha1 to match openssl's -ecdsa-with-SHA1 mode,
    or hashfunc=hashlib.sha256 for openssl-1.0.0's -ecdsa-with-SHA256.
:type hashfunc: callable
:param sigencode: function used to encode the signature.
    The function needs to accept three parameters: the two integers
    that are the signature and the order of the curve over which the
    signature was computed. It needs to return an encoded signature.
    See `ecdsa.util.sigencode_string` and `ecdsa.util.sigencode_der`
    as examples of such functions.
:type sigencode: callable
:param int k: a pre-selected nonce for calculating the signature.
    In typical use cases, it should be set to None (the default) to
    allow its generation from an entropy source.
:param bool allow_truncate: if True, the provided digest can have
    bigger bit-size than the order of the curve, the extra bits (at
    the end of the digest) will be truncated. Use it when signing
    SHA-384 output using NIST256p or in similar situations. True by
    default.

:raises RSZeroError: in the unlikely event when "r" parameter or
    "s" parameter of the created signature is equal 0, as that would
    leak the key. Caller should try a better entropy source, retry with
    different 'k', or use the
    :func:`~SigningKey.sign_deterministic` in such case.

:return: encoded signature of the hash of `data`
:rtype: bytes or sigencode function dependant type
</pre> 
</div>
</div>
<a id="af8a96e24413fb8a3da8d393ac7fd036e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8a96e24413fb8a3da8d393ac7fd036e">&#9670;&nbsp;</a></span>sign_deterministic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ecdsa.keys.SigningKey.sign_deterministic </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>hashfunc</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>sigencode</em> = <code>sigencode_string</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>extra_entropy</em> = <code>b&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Create signature over data using the deterministic RFC6979 algorithm.

The data will be hashed using the `hashfunc` function before signing.

This is the recommended method for performing signatures when hashing
of data is necessary.

:param data: data to be hashed and computed signature over
:type data: bytes like object
:param hashfunc: hash function to use for computing the signature,
    if unspecified, the default hash function selected during
    object initialisation will be used (see
    `VerifyingKey.default_hashfunc`). The object needs to implement
    the same interface as hashlib.sha1.
:type hashfunc: callable
:param sigencode: function used to encode the signature.
    The function needs to accept three parameters: the two integers
    that are the signature and the order of the curve over which the
    signature was computed. It needs to return an encoded signature.
    See `ecdsa.util.sigencode_string` and `ecdsa.util.sigencode_der`
    as examples of such functions.
:type sigencode: callable
:param extra_entropy: additional data that will be fed into the random
    number generator used in the RFC6979 process. Entirely optional.
:type extra_entropy: bytes like object

:return: encoded signature over `data`
:rtype: bytes or sigencode function dependant type
</pre> 
</div>
</div>
<a id="a147bcf40b4a968c69106975666651901"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a147bcf40b4a968c69106975666651901">&#9670;&nbsp;</a></span>sign_digest()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ecdsa.keys.SigningKey.sign_digest </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>digest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>entropy</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>sigencode</em> = <code>sigencode_string</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>k</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>allow_truncate</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Create signature over digest using the probabilistic ECDSA algorithm.

This method uses the standard ECDSA algorithm that requires a
cryptographically secure random number generator.

This method does not hash the input.

It's recommended to use the
:func:`~SigningKey.sign_digest_deterministic` method
instead of this one.

:param digest: hash value that will be signed
:type digest: bytes like object
:param callable entropy: randomness source, os.urandom by default
:param sigencode: function used to encode the signature.
    The function needs to accept three parameters: the two integers
    that are the signature and the order of the curve over which the
    signature was computed. It needs to return an encoded signature.
    See `ecdsa.util.sigencode_string` and `ecdsa.util.sigencode_der`
    as examples of such functions.
:type sigencode: callable
:param int k: a pre-selected nonce for calculating the signature.
    In typical use cases, it should be set to None (the default) to
    allow its generation from an entropy source.
:param bool allow_truncate: if True, the provided digest can have
    bigger bit-size than the order of the curve, the extra bits (at
    the end of the digest) will be truncated. Use it when signing
    SHA-384 output using NIST256p or in similar situations.

:raises RSZeroError: in the unlikely event when "r" parameter or
    "s" parameter of the created signature is equal 0, as that would
    leak the key. Caller should try a better entropy source, retry with
    different 'k', or use the
    :func:`~SigningKey.sign_digest_deterministic` in such case.

:return: encoded signature for the `digest` hash
:rtype: bytes or sigencode function dependant type
</pre> 
</div>
</div>
<a id="a10bee428751a86d1a20b352fada3f168"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10bee428751a86d1a20b352fada3f168">&#9670;&nbsp;</a></span>sign_digest_deterministic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ecdsa.keys.SigningKey.sign_digest_deterministic </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>digest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>hashfunc</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>sigencode</em> = <code>sigencode_string</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>extra_entropy</em> = <code>b&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>allow_truncate</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Create signature for digest using the deterministic RFC6979 algorithm.

`digest` should be the output of cryptographically secure hash function
like SHA256 or SHA-3-256.

This is the recommended method for performing signatures when no
hashing of data is necessary.

:param digest: hash of data that will be signed
:type digest: bytes like object
:param hashfunc: hash function to use for computing the random "k"
    value from RFC6979 process,
    if unspecified, the default hash function selected during
    object initialisation will be used (see
    `VerifyingKey.default_hashfunc`). The object needs to implement
    the same interface as hashlib.sha1.
:type hashfunc: callable
:param sigencode: function used to encode the signature.
    The function needs to accept three parameters: the two integers
    that are the signature and the order of the curve over which the
    signature was computed. It needs to return an encoded signature.
    See `ecdsa.util.sigencode_string` and `ecdsa.util.sigencode_der`
    as examples of such functions.
:type sigencode: callable
:param extra_entropy: additional data that will be fed into the random
    number generator used in the RFC6979 process. Entirely optional.
:type extra_entropy: bytes like object
:param bool allow_truncate: if True, the provided digest can have
    bigger bit-size than the order of the curve, the extra bits (at
    the end of the digest) will be truncated. Use it when signing
    SHA-384 output using NIST256p or in similar situations.

:return: encoded signature for the `digest` hash
:rtype: bytes or sigencode function dependant type
</pre> 
</div>
</div>
<a id="a5acd7a8d16c2e9ec7e3b2f6205e955cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5acd7a8d16c2e9ec7e3b2f6205e955cc">&#9670;&nbsp;</a></span>sign_number()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ecdsa.keys.SigningKey.sign_number </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>entropy</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>k</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Sign an integer directly.

Note, this is a low level method, usually you will want to use
:func:`~SigningKey.sign_deterministic` or
:func:`~SigningKey.sign_digest_deterministic`.

:param int number: number to sign using the probabilistic ECDSA
    algorithm.
:param callable entropy: entropy source, os.urandom by default
:param int k: pre-selected nonce for signature operation. If unset
    it will be selected at random using the entropy source.

:raises RSZeroError: in the unlikely event when "r" parameter or
    "s" parameter of the created signature is equal 0, as that would
    leak the key. Caller should try a better entropy source, retry with
    different 'k', or use the
    :func:`~SigningKey.sign_digest_deterministic` in such case.

:return: the "r" and "s" parameters of the signature
:rtype: tuple of ints
</pre> 
</div>
</div>
<a id="af41d921262712c4f57fb546ff463f405"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af41d921262712c4f57fb546ff463f405">&#9670;&nbsp;</a></span>to_der()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ecdsa.keys.SigningKey.to_der </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>point_encoding</em> = <code>&quot;uncompressed&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>format</em> = <code>&quot;ssleay&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>curve_parameters_encoding</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Convert the private key to the :term:`DER` format.

See :func:`~SigningKey.from_der` method for format specification.

Only the named curve format is supported.
The public key will be included in the generated string.

:param str point_encoding: format to use for encoding public point
:param str format: either ``ssleay`` (default) or ``pkcs8``
:param str curve_parameters_encoding: format of encoded curve
    parameters, default depends on the curve, if the curve has
    an associated OID, ``named_curve`` format will be used,
    if no OID is associated with the curve, the fallback of
    ``explicit`` parameters will be used.

:return: DER encoded private key
:rtype: bytes
</pre> 
</div>
</div>
<a id="ab3456753e9e100f802995ebb575d35ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3456753e9e100f802995ebb575d35ee">&#9670;&nbsp;</a></span>to_pem()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ecdsa.keys.SigningKey.to_pem </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>point_encoding</em> = <code>&quot;uncompressed&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>format</em> = <code>&quot;ssleay&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>curve_parameters_encoding</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Convert the private key to the :term:`PEM` format.

See :func:`~SigningKey.from_pem` method for format description.

Only the named curve format is supported.
The public key will be included in generated string.

The PEM header will specify ``BEGIN EC PRIVATE KEY`` or
``BEGIN PRIVATE KEY``, depending on the desired format.

:param str point_encoding: format to use for encoding public point
:param str format: either ``ssleay`` (default) or ``pkcs8``
:param str curve_parameters_encoding: format of encoded curve
    parameters, default depends on the curve, if the curve has
    an associated OID, ``named_curve`` format will be used,
    if no OID is associated with the curve, the fallback of
    ``explicit`` parameters will be used.

:return: PEM encoded private key
:rtype: bytes

.. warning:: The PEM is encoded to US-ASCII, it needs to be
    re-encoded if the system is incompatible (e.g. uses UTF-16)
</pre> 
</div>
</div>
<a id="a09689cd98260a48e527e6d469f52d362"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09689cd98260a48e527e6d469f52d362">&#9670;&nbsp;</a></span>to_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ecdsa.keys.SigningKey.to_string </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Convert the private key to :term:`raw encoding`.

Note: while the method is named "to_string", its name comes from
Python 2 days, when binary and character strings used the same type.
The type used in Python 3 is `bytes`.

:return: raw encoding of private key
:rtype: bytes
</pre> 
</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a548e8ca04bd9aeeac8e1702b543a3e0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a548e8ca04bd9aeeac8e1702b543a3e0d">&#9670;&nbsp;</a></span>baselen</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ecdsa.keys.SigningKey.baselen</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a27531450389917558b2f1673f6476f82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27531450389917558b2f1673f6476f82">&#9670;&nbsp;</a></span>curve</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ecdsa.keys.SigningKey.curve</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aca7644794fa76f443dca365d6a8e0dab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca7644794fa76f443dca365d6a8e0dab">&#9670;&nbsp;</a></span>default_hashfunc</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ecdsa.keys.SigningKey.default_hashfunc</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8e35bc07c03bd498969a7dcc4de390b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e35bc07c03bd498969a7dcc4de390b1">&#9670;&nbsp;</a></span>privkey</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ecdsa.keys.SigningKey.privkey</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aca047e8955fa7ed4514409611148a10b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca047e8955fa7ed4514409611148a10b">&#9670;&nbsp;</a></span>verifying_key</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ecdsa.keys.SigningKey.verifying_key</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>examples/aws_iot/venv/lib/python3.6/site-packages/ecdsa/<a class="el" href="keys_8py.html">keys.py</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceecdsa.html">ecdsa</a></li><li class="navelem"><a class="el" href="namespaceecdsa_1_1keys.html">keys</a></li><li class="navelem"><a class="el" href="classecdsa_1_1keys_1_1_signing_key.html">SigningKey</a></li>
    <li class="footer">Generated by <a href="https://iotready.co"> IoTReady </a><img class="footer" src="logo.png" width="30" height="30" alt="IoTReady"/></a></li>
  </ul>
</div>
</body>
</html>
