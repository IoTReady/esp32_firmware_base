<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ESP32 Quick Start Building Blocks: ecdsa.keys.VerifyingKey Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="customdoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="2" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ESP32 Quick Start Building Blocks
   </div>
   <!-- PROJECT BRIEF is expected to be a URL -->
   <div id="projectbrief"><a href=https://github.com/IoTReady/esp32_firmware_base>https://github.com/IoTReady/esp32_firmware_base</a></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classecdsa_1_1keys_1_1_verifying_key.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="classecdsa_1_1keys_1_1_verifying_key-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ecdsa.keys.VerifyingKey Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for ecdsa.keys.VerifyingKey:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classecdsa_1_1keys_1_1_verifying_key.png" alt=""/>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab1c45c1af6d3360cbece05a2463ee42b"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecdsa_1_1keys_1_1_verifying_key.html#ab1c45c1af6d3360cbece05a2463ee42b">__init__</a> (self, _error__please_use_generate=None)</td></tr>
<tr class="separator:ab1c45c1af6d3360cbece05a2463ee42b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d3d1d087febdcb4ca79e873e8aac5bf"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecdsa_1_1keys_1_1_verifying_key.html#a4d3d1d087febdcb4ca79e873e8aac5bf">__repr__</a> (self)</td></tr>
<tr class="separator:a4d3d1d087febdcb4ca79e873e8aac5bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3d86bf0fdfedb6706fc3cde722612a5"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecdsa_1_1keys_1_1_verifying_key.html#ab3d86bf0fdfedb6706fc3cde722612a5">__eq__</a> (self, other)</td></tr>
<tr class="separator:ab3d86bf0fdfedb6706fc3cde722612a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01efcdf9aaf8133d6a23943ebe83a9c9"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecdsa_1_1keys_1_1_verifying_key.html#a01efcdf9aaf8133d6a23943ebe83a9c9">__ne__</a> (self, other)</td></tr>
<tr class="separator:a01efcdf9aaf8133d6a23943ebe83a9c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2186d5162fc407bb9ac596f273cc6674"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecdsa_1_1keys_1_1_verifying_key.html#a2186d5162fc407bb9ac596f273cc6674">from_public_point</a> (cls, point, <a class="el" href="classecdsa_1_1keys_1_1_verifying_key.html#ae54a32b38650dfdfc335d475297d5f27">curve</a>=NIST192p, hashfunc=sha1, validate_point=True)</td></tr>
<tr class="separator:a2186d5162fc407bb9ac596f273cc6674"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f64168cd0b209bb4f500192ef19b798"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecdsa_1_1keys_1_1_verifying_key.html#a2f64168cd0b209bb4f500192ef19b798">precompute</a> (self, lazy=False)</td></tr>
<tr class="separator:a2f64168cd0b209bb4f500192ef19b798"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9eaf33a272f47f3062a5995f83ae36d5"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecdsa_1_1keys_1_1_verifying_key.html#a9eaf33a272f47f3062a5995f83ae36d5">from_string</a> (cls, string, <a class="el" href="classecdsa_1_1keys_1_1_verifying_key.html#ae54a32b38650dfdfc335d475297d5f27">curve</a>=NIST192p, hashfunc=sha1, validate_point=True, valid_encodings=None)</td></tr>
<tr class="separator:a9eaf33a272f47f3062a5995f83ae36d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5a0a1a18bc182884d8196fbfb3ee6bd"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecdsa_1_1keys_1_1_verifying_key.html#ab5a0a1a18bc182884d8196fbfb3ee6bd">from_pem</a> (cls, string, hashfunc=sha1, valid_encodings=None, valid_curve_encodings=None)</td></tr>
<tr class="separator:ab5a0a1a18bc182884d8196fbfb3ee6bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad62ebec7fd8541d62d6270588e825333"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecdsa_1_1keys_1_1_verifying_key.html#ad62ebec7fd8541d62d6270588e825333">from_der</a> (cls, string, hashfunc=sha1, valid_encodings=None, valid_curve_encodings=None)</td></tr>
<tr class="separator:ad62ebec7fd8541d62d6270588e825333"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a5b1d6ed31ab14816b743496bf3b0e2"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecdsa_1_1keys_1_1_verifying_key.html#a8a5b1d6ed31ab14816b743496bf3b0e2">from_public_key_recovery</a> (cls, signature, data, <a class="el" href="classecdsa_1_1keys_1_1_verifying_key.html#ae54a32b38650dfdfc335d475297d5f27">curve</a>, hashfunc=sha1, sigdecode=sigdecode_string, allow_truncate=True)</td></tr>
<tr class="separator:a8a5b1d6ed31ab14816b743496bf3b0e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1f1028eb2caaf9092b79be6de7b652b"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecdsa_1_1keys_1_1_verifying_key.html#af1f1028eb2caaf9092b79be6de7b652b">from_public_key_recovery_with_digest</a> (cls, signature, digest, <a class="el" href="classecdsa_1_1keys_1_1_verifying_key.html#ae54a32b38650dfdfc335d475297d5f27">curve</a>, hashfunc=sha1, sigdecode=sigdecode_string, allow_truncate=False)</td></tr>
<tr class="separator:af1f1028eb2caaf9092b79be6de7b652b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7880bddb122306825c3e96401cbee1fa"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecdsa_1_1keys_1_1_verifying_key.html#a7880bddb122306825c3e96401cbee1fa">to_string</a> (self, encoding=&quot;raw&quot;)</td></tr>
<tr class="separator:a7880bddb122306825c3e96401cbee1fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fd8a71519feb3e3742e605dfa9eeafc"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecdsa_1_1keys_1_1_verifying_key.html#a0fd8a71519feb3e3742e605dfa9eeafc">to_pem</a> (self, point_encoding=&quot;uncompressed&quot;, curve_parameters_encoding=None)</td></tr>
<tr class="separator:a0fd8a71519feb3e3742e605dfa9eeafc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b66546c737e8333643c0e2e6346b6bb"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecdsa_1_1keys_1_1_verifying_key.html#a9b66546c737e8333643c0e2e6346b6bb">to_der</a> (self, point_encoding=&quot;uncompressed&quot;, curve_parameters_encoding=None)</td></tr>
<tr class="separator:a9b66546c737e8333643c0e2e6346b6bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d0c4aee60ce1147d61afc11c8a3b39d"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecdsa_1_1keys_1_1_verifying_key.html#a2d0c4aee60ce1147d61afc11c8a3b39d">verify</a> (self, signature, data, hashfunc=None, sigdecode=sigdecode_string, allow_truncate=True)</td></tr>
<tr class="separator:a2d0c4aee60ce1147d61afc11c8a3b39d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad007291aa30b70ff65bb207adfbe81e5"><td class="memItemLeft" align="right" valign="top">def&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecdsa_1_1keys_1_1_verifying_key.html#ad007291aa30b70ff65bb207adfbe81e5">verify_digest</a> (self, signature, digest, sigdecode=sigdecode_string, allow_truncate=False)</td></tr>
<tr class="separator:ad007291aa30b70ff65bb207adfbe81e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:ae54a32b38650dfdfc335d475297d5f27"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecdsa_1_1keys_1_1_verifying_key.html#ae54a32b38650dfdfc335d475297d5f27">curve</a></td></tr>
<tr class="separator:ae54a32b38650dfdfc335d475297d5f27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d981c4beabdc68d58ce91b33e069cc4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecdsa_1_1keys_1_1_verifying_key.html#a8d981c4beabdc68d58ce91b33e069cc4">default_hashfunc</a></td></tr>
<tr class="separator:a8d981c4beabdc68d58ce91b33e069cc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20cc70f04b2dbb72098f505e47bd2b30"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classecdsa_1_1keys_1_1_verifying_key.html#a20cc70f04b2dbb72098f505e47bd2b30">pubkey</a></td></tr>
<tr class="separator:a20cc70f04b2dbb72098f505e47bd2b30"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><pre class="fragment">Class for handling keys that can verify signatures (public keys).

:ivar ecdsa.curves.Curve curve: The Curve over which all the cryptographic
    operations will take place
:ivar default_hashfunc: the function that will be used for hashing the
    data. Should implement the same API as hashlib.sha1
:vartype default_hashfunc: callable
:ivar pubkey: the actual public key
:vartype pubkey: ecdsa.ecdsa.Public_key
</pre> </div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ab1c45c1af6d3360cbece05a2463ee42b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1c45c1af6d3360cbece05a2463ee42b">&#9670;&nbsp;</a></span>__init__()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ecdsa.keys.VerifyingKey.__init__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>_error__please_use_generate</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Unsupported, please use one of the classmethods to initialise.</pre> 
</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ab3d86bf0fdfedb6706fc3cde722612a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3d86bf0fdfedb6706fc3cde722612a5">&#9670;&nbsp;</a></span>__eq__()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ecdsa.keys.VerifyingKey.__eq__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return True if the points are identical, False otherwise.</pre> 
</div>
</div>
<a id="a01efcdf9aaf8133d6a23943ebe83a9c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01efcdf9aaf8133d6a23943ebe83a9c9">&#9670;&nbsp;</a></span>__ne__()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ecdsa.keys.VerifyingKey.__ne__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return False if the points are identical, True otherwise.</pre> 
</div>
</div>
<a id="a4d3d1d087febdcb4ca79e873e8aac5bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d3d1d087febdcb4ca79e873e8aac5bf">&#9670;&nbsp;</a></span>__repr__()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ecdsa.keys.VerifyingKey.__repr__ </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad62ebec7fd8541d62d6270588e825333"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad62ebec7fd8541d62d6270588e825333">&#9670;&nbsp;</a></span>from_der()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ecdsa.keys.VerifyingKey.from_der </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>hashfunc</em> = <code>sha1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>valid_encodings</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>valid_curve_encodings</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Initialise the key stored in :term:`DER` format.

The expected format of the key is the SubjectPublicKeyInfo structure
from RFC5912 (for RSA keys, it's known as the PKCS#1 format)::

   SubjectPublicKeyInfo {PUBLIC-KEY: IOSet} ::= SEQUENCE {
       algorithm        AlgorithmIdentifier {PUBLIC-KEY, {IOSet}},
       subjectPublicKey BIT STRING
   }

Note: only public EC keys are supported by this method. The
SubjectPublicKeyInfo.algorithm.algorithm field must specify
id-ecPublicKey (see RFC3279).

Only the named curve encoding is supported, thus the
SubjectPublicKeyInfo.algorithm.parameters field needs to be an
object identifier. A sequence in that field indicates an explicit
parameter curve encoding, this format is not supported. A NULL object
in that field indicates an "implicitlyCA" encoding, where the curve
parameters come from CA certificate, those, again, are not supported.

:param string: binary string with the DER encoding of public ECDSA key
:type string: bytes-like object
:param valid_encodings: list of allowed point encodings.
    By default :term:`uncompressed`, :term:`compressed`, and
    :term:`hybrid`. To read malformed files, include
    :term:`raw encoding` with ``raw`` in the list.
:type valid_encodings: :term:`set-like object
:param valid_curve_encodings: list of allowed encoding formats
    for curve parameters. By default (``None``) all are supported:
    ``named_curve`` and ``explicit``.
:type valid_curve_encodings: :term:`set-like object`

:return: Initialised VerifyingKey object
:rtype: VerifyingKey
</pre> 
</div>
</div>
<a id="ab5a0a1a18bc182884d8196fbfb3ee6bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5a0a1a18bc182884d8196fbfb3ee6bd">&#9670;&nbsp;</a></span>from_pem()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ecdsa.keys.VerifyingKey.from_pem </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>hashfunc</em> = <code>sha1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>valid_encodings</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>valid_curve_encodings</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Initialise from public key stored in :term:`PEM` format.

The PEM header of the key should be ``BEGIN PUBLIC KEY``.

See the :func:`~VerifyingKey.from_der()` method for details of the
format supported.

Note: only a single PEM object decoding is supported in provided
string.

:param string: text with PEM-encoded public ECDSA key
:type string: str
:param valid_encodings: list of allowed point encodings.
    By default :term:`uncompressed`, :term:`compressed`, and
    :term:`hybrid`. To read malformed files, include
    :term:`raw encoding` with ``raw`` in the list.
:type valid_encodings: :term:`set-like object
:param valid_curve_encodings: list of allowed encoding formats
    for curve parameters. By default (``None``) all are supported:
    ``named_curve`` and ``explicit``.
:type valid_curve_encodings: :term:`set-like object`


:return: Initialised VerifyingKey object
:rtype: VerifyingKey
</pre> 
</div>
</div>
<a id="a8a5b1d6ed31ab14816b743496bf3b0e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a5b1d6ed31ab14816b743496bf3b0e2">&#9670;&nbsp;</a></span>from_public_key_recovery()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ecdsa.keys.VerifyingKey.from_public_key_recovery </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>signature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>curve</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>hashfunc</em> = <code>sha1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>sigdecode</em> = <code>sigdecode_string</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>allow_truncate</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return keys that can be used as verifiers of the provided signature.

Tries to recover the public key that can be used to verify the
signature, usually returns two keys like that.

:param signature: the byte string with the encoded signature
:type signature: bytes-like object
:param data: the data to be hashed for signature verification
:type data: bytes-like object
:param curve: the curve over which the signature was performed
:type curve: ecdsa.curves.Curve
:param hashfunc: The default hash function that will be used for
    verification, needs to implement the same interface as hashlib.sha1
:type hashfunc: callable
:param sigdecode: Callable to define the way the signature needs to
    be decoded to an object, needs to handle `signature` as the
    first parameter, the curve order (an int) as the second and return
    a tuple with two integers, "r" as the first one and "s" as the
    second one. See :func:`ecdsa.util.sigdecode_string` and
    :func:`ecdsa.util.sigdecode_der` for examples.
:param bool allow_truncate: if True, the provided hashfunc can generate
    values larger than the bit size of the order of the curve, the
    extra bits (at the end of the digest) will be truncated.
:type sigdecode: callable

:return: Initialised VerifyingKey objects
:rtype: list of VerifyingKey
</pre> 
</div>
</div>
<a id="af1f1028eb2caaf9092b79be6de7b652b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1f1028eb2caaf9092b79be6de7b652b">&#9670;&nbsp;</a></span>from_public_key_recovery_with_digest()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ecdsa.keys.VerifyingKey.from_public_key_recovery_with_digest </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>signature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>digest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>curve</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>hashfunc</em> = <code>sha1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>sigdecode</em> = <code>sigdecode_string</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>allow_truncate</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Return keys that can be used as verifiers of the provided signature.

Tries to recover the public key that can be used to verify the
signature, usually returns two keys like that.

:param signature: the byte string with the encoded signature
:type signature: bytes-like object
:param digest: the hash value of the message signed by the signature
:type digest: bytes-like object
:param curve: the curve over which the signature was performed
:type curve: ecdsa.curves.Curve
:param hashfunc: The default hash function that will be used for
    verification, needs to implement the same interface as hashlib.sha1
:type hashfunc: callable
:param sigdecode: Callable to define the way the signature needs to
    be decoded to an object, needs to handle `signature` as the
    first parameter, the curve order (an int) as the second and return
    a tuple with two integers, "r" as the first one and "s" as the
    second one. See :func:`ecdsa.util.sigdecode_string` and
    :func:`ecdsa.util.sigdecode_der` for examples.
:type sigdecode: callable
:param bool allow_truncate: if True, the provided hashfunc can generate
    values larger than the bit size of the order of the curve (and
    the length of provided `digest`), the extra bits (at the end of the
    digest) will be truncated.

:return: Initialised VerifyingKey object
:rtype: VerifyingKey
</pre> 
</div>
</div>
<a id="a2186d5162fc407bb9ac596f273cc6674"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2186d5162fc407bb9ac596f273cc6674">&#9670;&nbsp;</a></span>from_public_point()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ecdsa.keys.VerifyingKey.from_public_point </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>curve</em> = <code>NIST192p</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>hashfunc</em> = <code>sha1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>validate_point</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Initialise the object from a Point object.

This is a low-level method, generally you will not want to use it.

:param point: The point to wrap around, the actual public key
:type point: ecdsa.ellipticcurve.Point
:param curve: The curve on which the point needs to reside, defaults
    to NIST192p
:type curve: ecdsa.curves.Curve
:param hashfunc: The default hash function that will be used for
    verification, needs to implement the same interface
    as hashlib.sha1
:type hashfunc: callable
:type bool validate_point: whether to check if the point lays on curve
    should always be used if the public point is not a result
    of our own calculation

:raises MalformedPointError: if the public point does not lay on the
    curve

:return: Initialised VerifyingKey object
:rtype: VerifyingKey
</pre> 
</div>
</div>
<a id="a9eaf33a272f47f3062a5995f83ae36d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9eaf33a272f47f3062a5995f83ae36d5">&#9670;&nbsp;</a></span>from_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ecdsa.keys.VerifyingKey.from_string </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>cls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>curve</em> = <code>NIST192p</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>hashfunc</em> = <code>sha1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>validate_point</em> = <code>True</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>valid_encodings</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Initialise the object from byte encoding of public key.

The method does accept and automatically detect the type of point
encoding used. It supports the :term:`raw encoding`,
:term:`uncompressed`, :term:`compressed`, and :term:`hybrid` encodings.

Note, while the method is named "from_string" it's a misnomer from
Python 2 days when there were no binary strings. In Python 3 the
input needs to be a bytes-like object.

:param string: single point encoding of the public key
:type string: :term:`bytes-like object`
:param curve: the curve on which the public key is expected to lay
:type curve: ecdsa.curves.Curve
:param hashfunc: The default hash function that will be used for
    verification, needs to implement the same interface as hashlib.sha1
:type hashfunc: callable
:param validate_point: whether to verify that the point lays on the
    provided curve or not, defaults to True
:type validate_point: bool
:param valid_encodings: list of acceptable point encoding formats,
    supported ones are: :term:`uncompressed`, :term:`compressed`,
    :term:`hybrid`, and :term:`raw encoding` (specified with ``raw``
    name). All formats by default (specified with ``None``).
:type valid_encodings: :term:`set-like object`

:raises MalformedPointError: if the public point does not lay on the
    curve or the encoding is invalid

:return: Initialised VerifyingKey object
:rtype: VerifyingKey
</pre> 
</div>
</div>
<a id="a2f64168cd0b209bb4f500192ef19b798"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f64168cd0b209bb4f500192ef19b798">&#9670;&nbsp;</a></span>precompute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ecdsa.keys.VerifyingKey.precompute </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>lazy</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Precompute multiplication tables for faster signature verification.

Calling this method will cause the library to precompute the
scalar multiplication tables, used in signature verification.
While it's an expensive operation (comparable to performing
as many signatures as the bit size of the curve, i.e. 256 for NIST256p)
it speeds up verification 2 times. You should call this method
if you expect to verify hundreds of signatures (or more) using the same
VerifyingKey object.

Note: You should call this method only once, this method generates a
new precomputation table every time it's called.

:param bool lazy: whether to calculate the precomputation table now
   (if set to False) or if it should be delayed to the time of first
   use (when set to True)
</pre> 
</div>
</div>
<a id="a9b66546c737e8333643c0e2e6346b6bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b66546c737e8333643c0e2e6346b6bb">&#9670;&nbsp;</a></span>to_der()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ecdsa.keys.VerifyingKey.to_der </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>point_encoding</em> = <code>&quot;uncompressed&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>curve_parameters_encoding</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Convert the public key to the :term:`DER` format.

The format of the key is described in the
:func:`~VerifyingKey.from_der()` method.
This method supports only "named curve" encoding of keys.

:param str point_encoding: specification of the encoding format
    of public keys. "uncompressed" is most portable, "compressed" is
    smallest. "hybrid" is uncommon and unsupported by most
    implementations, it is as big as "uncompressed".
:param str curve_parameters_encoding: the encoding for curve parameters
    to use, by default tries to use ``named_curve`` encoding,
    if that is not possible, falls back to ``named_curve`` encoding.

:return: DER encoding of the public key
:rtype: bytes
</pre> 
</div>
</div>
<a id="a0fd8a71519feb3e3742e605dfa9eeafc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fd8a71519feb3e3742e605dfa9eeafc">&#9670;&nbsp;</a></span>to_pem()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ecdsa.keys.VerifyingKey.to_pem </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>point_encoding</em> = <code>&quot;uncompressed&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>curve_parameters_encoding</em> = <code>None</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Convert the public key to the :term:`PEM` format.

The PEM header of the key will be ``BEGIN PUBLIC KEY``.

The format of the key is described in the
:func:`~VerifyingKey.from_der()` method.
This method supports only "named curve" encoding of keys.

:param str point_encoding: specification of the encoding format
    of public keys. "uncompressed" is most portable, "compressed" is
    smallest. "hybrid" is uncommon and unsupported by most
    implementations, it is as big as "uncompressed".
:param str curve_parameters_encoding: the encoding for curve parameters
    to use, by default tries to use ``named_curve`` encoding,
    if that is not possible, falls back to ``named_curve`` encoding.

:return: portable encoding of the public key
:rtype: bytes

.. warning:: The PEM is encoded to US-ASCII, it needs to be
    re-encoded if the system is incompatible (e.g. uses UTF-16)
</pre> 
</div>
</div>
<a id="a7880bddb122306825c3e96401cbee1fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7880bddb122306825c3e96401cbee1fa">&#9670;&nbsp;</a></span>to_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ecdsa.keys.VerifyingKey.to_string </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>encoding</em> = <code>&quot;raw&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Convert the public key to a byte string.

The method by default uses the :term:`raw encoding` (specified
by `encoding="raw"`. It can also output keys in :term:`uncompressed`,
:term:`compressed` and :term:`hybrid` formats.

Remember that the curve identification is not part of the encoding
so to decode the point using :func:`~VerifyingKey.from_string`, curve
needs to be specified.

Note: while the method is called "to_string", it's a misnomer from
Python 2 days when character strings and byte strings shared type.
On Python 3 the returned type will be `bytes`.

:return: :term:`raw encoding` of the public key (public point) on the
    curve
:rtype: bytes
</pre> 
</div>
</div>
<a id="a2d0c4aee60ce1147d61afc11c8a3b39d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d0c4aee60ce1147d61afc11c8a3b39d">&#9670;&nbsp;</a></span>verify()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ecdsa.keys.VerifyingKey.verify </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>signature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>hashfunc</em> = <code>None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>sigdecode</em> = <code>sigdecode_string</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>allow_truncate</em> = <code>True</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Verify a signature made over provided data.

Will hash `data` to verify the signature.

By default expects signature in :term:`raw encoding`. Can also be used
to verify signatures in ASN.1 DER encoding by using
:func:`ecdsa.util.sigdecode_der`
as the `sigdecode` parameter.

:param signature: encoding of the signature
:type signature: sigdecode method dependant
:param data: data signed by the `signature`, will be hashed using
    `hashfunc`, if specified, or default hash function
:type data: bytes like object
:param hashfunc: The default hash function that will be used for
    verification, needs to implement the same interface as hashlib.sha1
:type hashfunc: callable
:param sigdecode: Callable to define the way the signature needs to
    be decoded to an object, needs to handle `signature` as the
    first parameter, the curve order (an int) as the second and return
    a tuple with two integers, "r" as the first one and "s" as the
    second one. See :func:`ecdsa.util.sigdecode_string` and
    :func:`ecdsa.util.sigdecode_der` for examples.
:type sigdecode: callable
:param bool allow_truncate: if True, the provided digest can have
    bigger bit-size than the order of the curve, the extra bits (at
    the end of the digest) will be truncated. Use it when verifying
    SHA-384 output using NIST256p or in similar situations. Defaults to
    True.

:raises BadSignatureError: if the signature is invalid or malformed

:return: True if the verification was successful
:rtype: bool
</pre> 
</div>
</div>
<a id="ad007291aa30b70ff65bb207adfbe81e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad007291aa30b70ff65bb207adfbe81e5">&#9670;&nbsp;</a></span>verify_digest()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">def ecdsa.keys.VerifyingKey.verify_digest </td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>signature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>digest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>sigdecode</em> = <code>sigdecode_string</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>allow_truncate</em> = <code>False</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre class="fragment">Verify a signature made over provided hash value.

By default expects signature in :term:`raw encoding`. Can also be used
to verify signatures in ASN.1 DER encoding by using
:func:`ecdsa.util.sigdecode_der`
as the `sigdecode` parameter.

:param signature: encoding of the signature
:type signature: sigdecode method dependant
:param digest: raw hash value that the signature authenticates.
:type digest: bytes like object
:param sigdecode: Callable to define the way the signature needs to
    be decoded to an object, needs to handle `signature` as the
    first parameter, the curve order (an int) as the second and return
    a tuple with two integers, "r" as the first one and "s" as the
    second one. See :func:`ecdsa.util.sigdecode_string` and
    :func:`ecdsa.util.sigdecode_der` for examples.
:type sigdecode: callable
:param bool allow_truncate: if True, the provided digest can have
    bigger bit-size than the order of the curve, the extra bits (at
    the end of the digest) will be truncated. Use it when verifying
    SHA-384 output using NIST256p or in similar situations.

:raises BadSignatureError: if the signature is invalid or malformed
:raises BadDigestError: if the provided digest is too big for the curve
    associated with this VerifyingKey and allow_truncate was not set

:return: True if the verification was successful
:rtype: bool
</pre> 
</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ae54a32b38650dfdfc335d475297d5f27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae54a32b38650dfdfc335d475297d5f27">&#9670;&nbsp;</a></span>curve</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ecdsa.keys.VerifyingKey.curve</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8d981c4beabdc68d58ce91b33e069cc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d981c4beabdc68d58ce91b33e069cc4">&#9670;&nbsp;</a></span>default_hashfunc</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ecdsa.keys.VerifyingKey.default_hashfunc</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a20cc70f04b2dbb72098f505e47bd2b30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20cc70f04b2dbb72098f505e47bd2b30">&#9670;&nbsp;</a></span>pubkey</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ecdsa.keys.VerifyingKey.pubkey</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>examples/aws_iot/venv/lib/python3.6/site-packages/ecdsa/<a class="el" href="keys_8py.html">keys.py</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceecdsa.html">ecdsa</a></li><li class="navelem"><a class="el" href="namespaceecdsa_1_1keys.html">keys</a></li><li class="navelem"><a class="el" href="classecdsa_1_1keys_1_1_verifying_key.html">VerifyingKey</a></li>
    <li class="footer">Generated by <a href="https://iotready.co"> IoTReady </a><img class="footer" src="logo.png" width="30" height="30" alt="IoTReady"/></a></li>
  </ul>
</div>
</body>
</html>
